import io

import qrcode
from PIL import Image, ImageDraw, ImageFont

from helper.logger_utils import force_log


class QRGenerator:
    """Utility class for generating QR codes with text overlay"""
    
    def __init__(self):
        self.logger_name = "QRGenerator"
    
    def generate_wifi_qr_with_text(self, wifi_name: str, wifi_password: str) -> Image.Image:
        """
        Generate a WiFi QR code with formatted text below it
        
        Args:
            wifi_name: WiFi network name (SSID)
            wifi_password: WiFi password
            
        Returns:
            PIL Image with QR code and text
        """
        try:
            # Create WiFi configuration string
            wifi_config = f"WIFI:T:WPA;S:{wifi_name};P:{wifi_password};;"
            force_log(f"Creating WiFi QR for: {wifi_name}", self.logger_name)
            
            # Generate QR code
            qr_img = self._create_qr_code(wifi_config)
            
            # Add text below QR code
            final_img = self._add_text_overlay(qr_img, wifi_name, wifi_password)
            
            force_log(f"Successfully generated WiFi QR with text for: {wifi_name}", self.logger_name)
            return final_img
            
        except Exception as e:
            force_log(f"Error generating WiFi QR with text: {e}", self.logger_name)
            raise e
    
    def _create_qr_code(self, data: str) -> Image.Image:
        """Create basic QR code image"""
        try:
            qr = qrcode.QRCode(
                version=1,
                error_correction=qrcode.constants.ERROR_CORRECT_L,
                box_size=20,  # Increased from 10 to 20 for higher resolution
                border=1,  # Reduced border from 4 to 1
            )
            qr.add_data(data)
            qr.make(fit=True)
            
            # Create QR code image and convert to proper PIL Image
            qr_img = qr.make_image(fill_color="black", back_color="white")
            
            # Convert to RGB PIL Image to ensure compatibility
            if qr_img.mode != 'RGB':
                qr_img = qr_img.convert('RGB')
            
            force_log(f"QR code created successfully, size: {qr_img.size}, mode: {qr_img.mode}", self.logger_name)
            return qr_img
            
        except Exception as e:
            force_log(f"Error creating QR code: {e}", self.logger_name)
            raise e
    
    def _add_text_overlay(self, qr_img: Image.Image, wifi_name: str, wifi_password: str) -> Image.Image:
        """Add text overlay below QR code"""
        try:
            # Get QR code dimensions
            qr_width, qr_height = qr_img.size
            force_log(f"QR image size: {qr_width}x{qr_height}", self.logger_name)
            
            # Create new image with space for text (increased for proper spacing)
            text_area_height = 200  # Increased from 160 to 200 to accommodate all text
            total_height = qr_height + text_area_height
            final_img = Image.new('RGB', (qr_width, total_height), 'white')
            
            # Paste QR code at top
            final_img.paste(qr_img, (0, 0))
            force_log("QR code pasted to final image", self.logger_name)
            
            # Add text
            self._draw_text_lines(final_img, qr_width, qr_height, wifi_name, wifi_password)
            
            return final_img
            
        except Exception as e:
            force_log(f"Error adding text overlay: {e}", self.logger_name)
            raise e
    
    def _draw_text_lines(self, img: Image.Image, qr_width: int, qr_height: int, wifi_name: str, wifi_password: str):
        """Draw text lines below QR code"""
        try:
            draw = ImageDraw.Draw(img)
            
            # Load fonts
            font = self._load_font(12)
            font_small = self._load_font(10)
            
            # Text content
            lines = [
                f"WiFi Name: {wifi_name}",
                f"Password: {wifi_password}",
                "- - - - - - -- - - - - - -",
                "QR generated by AutoSum"
            ]
            
            # Text positioning (reduced gap between QR and text)
            start_y = qr_height + 5  # Adjusted for higher resolution
            line_height = 35  # Increased for higher resolution text
            
            # Draw each line with custom spacing
            for i, line in enumerate(lines):
                if i == 0:  # WiFi Name
                    y_pos = start_y
                    current_font = font
                elif i == 1:  # Password - add extra space after WiFi Name
                    y_pos = start_y + line_height + 20  # Extra 20px space between WiFi Name and Password
                    current_font = font
                elif i == 2:  # Separator - add extra space
                    y_pos = start_y + (2 * line_height) + 35  # Account for extra space above
                    current_font = font_small
                else:  # Footer - smaller font and size
                    y_pos = start_y + (3 * line_height) + 35  # Maintain spacing
                    current_font = self._load_font(8)  # Even smaller font for footer
                
                # Center the text
                x_pos = self._get_centered_x_position(draw, line, current_font, qr_width)
                
                draw.text((x_pos, y_pos), line, fill="black", font=current_font)
                force_log(f"Drew line {i+1}: '{line}' at ({x_pos}, {y_pos})", self.logger_name)
                
        except Exception as e:
            force_log(f"Error drawing text lines: {e}", self.logger_name)
            raise e
    
    def _load_font(self, size: int) -> ImageFont.FreeTypeFont:
        """Load font with fallback options - doubled size"""
        try:
            # Increase font size for higher resolution
            actual_size = size * 4  # Increased from 2x to 4x for higher resolution
            
            # Try different font paths
            font_paths = [
                "Arial.ttf",
                "/System/Library/Fonts/Arial.ttf",
                "/usr/share/fonts/truetype/arial.ttf",
                "/Windows/Fonts/arial.ttf"
            ]
            
            for path in font_paths:
                try:
                    font = ImageFont.truetype(path, actual_size)
                    force_log(f"Loaded font: {path}, size: {actual_size}", self.logger_name)
                    return font
                except (OSError, IOError):
                    continue
            
            # Fallback to default
            font = ImageFont.load_default()
            force_log(f"Using default font, size: {actual_size}", self.logger_name)
            return font
            
        except Exception as e:
            force_log(f"Error loading font: {e}", self.logger_name)
            return ImageFont.load_default()
    
    def _get_centered_x_position(self, draw: ImageDraw.ImageDraw, text: str, font: ImageFont.FreeTypeFont, img_width: int) -> int:
        """Get x position to center text"""
        try:
            # Try modern method first
            try:
                bbox = draw.textbbox((0, 0), text, font=font)
                text_width = bbox[2] - bbox[0]
                force_log(f"Text width calculated using textbbox: {text_width}", self.logger_name)
            except Exception:
                # Fallback to older method
                try:
                    text_width = draw.textsize(text, font=font)[0]
                    force_log(f"Text width calculated using textsize: {text_width}", self.logger_name)
                except Exception:
                    # Final fallback: estimate (adjusted based on font size)
                    # Check if this is likely a smaller font (footer text)
                    if "AutoSum" in text or len(text) < 30:
                        text_width = len(text) * 20  # Smaller multiplier for footer
                    else:
                        text_width = len(text) * 28  # Normal size for main text
                    force_log(f"Text width estimated: {text_width}", self.logger_name)
            
            x_pos = max(0, (img_width - text_width) // 2)
            return x_pos
            
        except Exception as e:
            force_log(f"Error calculating text position: {e}, using fallback", self.logger_name)
            return 10  # Fallback to left margin
    
    def image_to_bytes(self, img: Image.Image, format: str = 'PNG') -> io.BytesIO:
        """Convert PIL Image to bytes"""
        try:
            bio = io.BytesIO()
            img.save(bio, format=format)
            bio.seek(0)
            force_log(f"Image converted to bytes, format: {format}", self.logger_name)
            return bio
        except Exception as e:
            force_log(f"Error converting image to bytes: {e}", self.logger_name)
            raise e